<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: streams/stream.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: streams/stream.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>
 *  Constructs a ProAct.Stream. The stream is a simple {@link ProAct.Observable}, without state.
 * &lt;/p>
 * &lt;p>
 *  The streams are ment to emit values, events, changes and can be plugged into another observables.
 *  For example you can connect many streams, to merge them and to divide them, to plug them into properties.
 * &lt;/p>
 * &lt;p>
 *  The reactive environment consists of the properties and the objects containing them, but
 *  the outside world is not reactive. It is possible to use the ProAct.Streams as connections from the
 *  outside world to the reactive environment.
 * &lt;/p>
 * &lt;p>
 *    The transformations can be used to change the events or values emitetted.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Stream is part of the streams module of ProAct.js.
 * &lt;/p>
 *
 * @class ProAct.Stream
 * @extends ProAct.Observable
 * @param {ProAct.Observable} source
 *      A devfault source of the stream, can be null.
 * @param {Array} transforms
 *      A list of transformation to be used on all incoming chages.
 */
ProAct.Stream = ProAct.S = function (source, transforms) {
  P.Observable.call(this, transforms);

  if (source) {
    this.into(source);
  }
};

ProAct.Stream.prototype = P.U.ex(Object.create(P.Observable.prototype), {

  /**
   * Reference to the constructor of this object.
   *
   * @memberof ProAct.Stream
   * @instance
   * @constant
   * @type {Object}
   * @default ProAct.Stream
   */
  constructor: ProAct.Stream,

  /**
   * Creates the &lt;i>event&lt;/i> to be send to the listeners on update.
   * &lt;p>
   *  Streams don't create new events by default, the event is the source.
   * &lt;/p>
   *
   * @memberof ProAct.Stream
   * @instance
   * @method makeEvent
   * @default {ProAct.Event} with type {@link ProAct.Event.Types.value}
   * @param {ProAct.Event} source
   *      The source event of the event. It can be null
   * @return {ProAct.Event}
   *      The event.
   */
  makeEvent: function (source) {
    return source;
  },
  makeListener: function (source) {
    if (!this.listener) {
      var stream = this;
      this.listener = function (event) {
        stream.trigger(event, true);
      };
    }

    return this.listener;
  },
  makeErrListener: function (source) {
    if (!this.errListener) {
      var stream = this;
      this.errListener = function (error) {
        stream.triggerErr(error);
      };
    }

    return this.errListener;
  },
  defer: function (event, callback) {
    if (callback.property) {
      P.Observable.prototype.defer.call(this, event, callback);
      return;
    }

    if (P.U.isFunction(callback)) {
      P.flow.push(callback, [event]);
    } else {
      P.flow.push(callback, callback.call, [event]);
    }
  },
  trigger: function (event, useTransformations) {
    if (useTransformations === undefined) {
      useTransformations = true;
    }
    return this.go(event, useTransformations);
  },
  triggerErr: function (err) {
    return this.update(err, this.errListeners);
  },
  go: function (event, useTransformations) {
    var i, tr = this.transforms, ln = tr.length;

    if (useTransformations) {
      try {
        event = P.Observable.transform(this, event);
      } catch (e) {
        this.triggerErr(e);
        return this;
      }
    }

    if (event === P.Observable.BadValue) {
      return this;
    }

    return this.update(event);
  },
  map: function (f) {
    return new P.S(this).mapping(f);
  },
  filter: function (f) {
    return new P.S(this).filtering(f);
  },
  accumulate: function (initVal, f) {
    return new P.S(this).accumulation(initVal, f);
  },
  merge: function (stream) {
    return new P.S().into(this, stream);
  }
});

P.U.ex(P.F.prototype, {
  errStream: function () {
    if (!this.errStreamVar) {
      this.errStreamVar = new P.S();
    }

    return this.errStreamVar;
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Event.html">Event</a></li><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.Observable.html">Observable</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li><li><a href="ProAct.Stream.html">Stream</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.Event.Types.html">Types</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul><h3>Global</h3><ul><li><a href="global.html#BadValue">BadValue</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Fri Jul 18 2014 14:04:05 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
