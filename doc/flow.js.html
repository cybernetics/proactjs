<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: flow/flow.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: flow/flow.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * &lt;p>
 *  Constructs the action flow of the ProAct.js; An action flow is a set of actions
 *  executed in the reactive environment, which order is determined by the dependencies
 *  between the reactive properties. The action flow puts on motion the data flow in the reactive
 *  ecosystem. Every change on a property triggers an action flow, which triggers the data flow.
 * &lt;/p>
 *  ProAct.Flow is a simple fork of the [Ember's Backburner.js]{@link https://github.com/ebryn/backburner.js}.
 *  The different things are the priority queues and some optimizations. It doesn't include debouncing and timed defer of actions.
 * &lt;p>
 *  ProAct.Flow is used to solve many of the problems in the reactive programming, for example the diamond problem.
 * &lt;/p>
 * &lt;p>
 *  It can be used for other purposes too, for exmple to run rendering in a rendering queue, after all of the property updates.
 * &lt;/p>
 * &lt;p>
 *  ProAct.Flow, {@link ProAct.Queues} and {@link ProAct.Queue} together form the ActiveFlow module of ProAct.
 * &lt;/p>
 *
 * @class ProAct.Flow
 * @param {Array} queueNames
 *      Array with the names of the sub-queues of the {@link ProAct.Queues}es of the flow. The size of this array determines
 *      the number of the sub-queues.
 * @param {Object} options
 *    Various options for the ProAct.Flow.
 *    &lt;p>Available options:&lt;/p>
 *    &lt;ul>
 *      &lt;li>start - A callback that will be called every time when the action flow starts.&lt;/li>
 *      &lt;li>stop - A callback that will be called every time when the action flow ends.&lt;/li>
 *      &lt;li>err - A callback that will be called if an error is thrown in the action flow.&lt;/li>
 *      &lt;li>flowInstance - Options object for the current flow instance. The flow instances are @{link ProAct.Queues}es.&lt;/li>
 *    &lt;/ul>
 * @see {@link ProAct.Queues}
 * @see {@link ProAct.Queue}
 */
ProAct.Flow = P.F = function (queueNames, options) {
  if (!queueNames) {
    queueNames = ['proq'];
  }

  this.queueNames = queueNames;
  this.options = options || {};

  this.flowInstance = null;
  this.flowInstances = [];

  this.pauseMode = false;
};

Pro.Flow.prototype = {
  constructor: Pro.Flow,
  start: function () {
    var queues = this.flowInstance,
        options = this.options,
        start = options && options.start,
        queueNames = this.queueNames;

    if (queues) {
      this.flowInstances.push(queues);
    }

    this.flowInstance = new Pro.Queues(queueNames, options.flowInstance);

    if (start) {
      start(this.flowInstance);
    }
  },
  stop: function () {
    var queues = this.flowInstance,
        options = this.options,
        stop = options && options.stop,
        nextQueues;

    if (queues) {
      try {
        queues.go();
      } finally {
        this.flowInstance = null;

        if (this.flowInstances.length) {
          nextQueues = this.flowInstances.pop();
          this.flowInstance = nextQueues;
        }

        if (stop) {
          stop(queues);
        }
      }
    }
  },
  pause: function () {
    this.pauseMode = true;
  },
  resume: function () {
    this.pauseMode = false;
  },
  run: function (obj, method) {
    var options = this.options,
        err = options.err;

    this.start();
    if (!method) {
      method = obj;
      obj = null;
    }

    try {
      if (err) {
        try {
          method.call(obj);
        } catch (e) {
          err(e);
        }
      } else {
        method.call(obj);
      }
    } finally {
      this.stop();
    }
  },
  isRunning: function () {
    return this.flowInstance !== null && this.flowInstance !== undefined;
  },
  isPaused: function () {
    return this.isRunning() && this.pauseMode;
  },
  push: function (queueName, obj, method, args) {
    if (!this.flowInstance) {
      throw new Error('Not in running flow!');
    }
    if (!this.isPaused()) {
      this.flowInstance.push(queueName, obj, method, args);
    }
  },
  pushOnce: function (queueName, obj, method, args) {
    if (!this.flowInstance) {
      throw new Error('Not in running flow!');
    }
    if (!this.isPaused()) {
      this.flowInstance.pushOnce(queueName, obj, method, args);
    }
  }
};

Pro.flow = new Pro.Flow(['proq'], {
  err: function (e) {
    if (Pro.flow.errStream()) {
      Pro.flow.errStream().triggerErr(e);
    } else {
      console.log(e);
    }
  },
  flowInstance: {
    queue: {
      err: function (queue, e) {
        if (Pro.flow.errStream()) {
          Pro.flow.errStream().triggerErr(e);
        } else {
          console.log(e);
        }
      }
    }
  }
});
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Fri Jul 11 2014 00:10:09 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
