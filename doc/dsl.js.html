<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: registry/dsl.js</title>
    
    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">
    
    <h1 class="page-title">Source: registry/dsl.js</h1>
    
    


    
    <section>
        <article>
            <pre class="prettyprint source"><code>/**
 * Contains {@link ProAct.DSl} operation logic definitions.
 * &lt;p>
 *  Every operation has
 *  &lt;ol>
 *    &lt;li>&lt;b>sym&lt;/b> - A symbol used to identify the right operation in a DSL string or object.&lt;/li>
 *    &lt;li>&lt;b>match method&lt;/b> - A method used for identifying the operation, usually it uses the &lt;i>sym&lt;/i>&lt;/li>
 *    &lt;li>
 *      &lt;b>toOptions&lt;/b> - A method which is able to turn a DSL string with the operation,
 *      into an actual array of options containing all the functions to be executed by the DSL and their arguments.
 *    &lt;/li>
 *    &lt;li>&lt;b>action&lt;/b> - The operation logic. The options object of the above method should be passed to it, as well as the targed on which the DSL should be run.&lt;/li>
 *  &lt;/ol>
 * &lt;/p>
 *
 * @namespace ProAct.OpStore
 */
ProAct.OpStore = {

  /**
   * Default operation definitions, that can be used by most of the operations to be defined.
   *
   * @memberof ProAct.OpStore
   * @static
   * @constant
   */
  all: {

    /**
     * Can generate a simple operation definition.
     * &lt;p>
     *  It is used for defining all the simple operations, like &lt;i>map&lt;/i> or &lt;i>filter&lt;/i>.
     * &lt;/p>
     *
     * @memberof ProAct.OpStore.all
     * @static
     * @param {String} name
     *      The name of the operation to define.
     * @param {String} sym
     *      The symbol of the operation that shoul dbe used to identify it from within a DSL string.
     * @return {Object}
     *      &lt;ol>
     *        &lt;li>&lt;b>sym&lt;/b> - The symbol used to identify the operation in a DSL string or object.&lt;/li>
     *        &lt;li>&lt;b>match method&lt;/b> - A method using the &lt;i>sym&lt;/i> for identifying the operation in a DSL string.&lt;/li>
     *        &lt;li>
     *          &lt;b>toOptions&lt;/b> - A method which is able to turn a DSL string with the operation,
     *          into the actual array of options containing all the functions to be executed by the DSL and their arguments.
     *          &lt;p>
     *            This method is able to fetch predefined operation functions.
     *          &lt;/p>
     *        &lt;/li>
     *        &lt;li>
     *          &lt;b>action&lt;/b> - The operation logic.
     *          The options object of the above method should be passed to it, as well as the targed on which the DSL should be run.
     *          &lt;p>
     *            It just calls method named as the passed &lt;i>name&lt;/i> parameter on the targed &lt;i>object&lt;/i>, passing it as arguments,
     *            the argument array generated from the &lt;i>toOptions&lt;/i> method.
     *          &lt;/p>
     *        &lt;/li>
     *      &lt;/ol>
     * @see {@link ProAct.DSl.predefined}
     */
    simpleOp: function(name, sym) {
      return {
        sym: sym,
        match: function (op) {
          return op.substring(0, sym.length) === sym;
        },
        toOptions: function (actionObject, op) {
          var reg = new RegExp(dslOps[name].sym + "(\\w*)\\(([\\s\\S]*)\\)"),
              matched = reg.exec(op),
              action = matched[1], args = matched[2],
              opArguments = [],
              realArguments = slice.call(arguments, 2),
              predefined = dsl.predefined[name],
              arg, i , ln, k;
          if (action) {
            opArguments.push(action);
          }

          if (args) {
            args = args.split(',');
            ln = args.length;
            for (i = 0; i &lt; ln; i++) {
              arg = args[i].trim();
              if (arg.charAt(0) === '$') {
                arg = realArguments[parseInt(arg.substring(1), 10) - 1];
              } else if (predefined && arg.charAt(0) === '&') {
                i = arg.lastIndexOf('&');
                k = arg.substring(0, i);
                if (predefined[k]) {
                  arg = predefined[k].call(null, arg.substring(i + 1));
                }
              } else if (predefined && predefined[arg]) {
                arg = predefined[arg];

                if (P.U.isArray(arg)) {
                  opArguments = opArguments.concat(arg);
                  arg = undefined;
                }
              }

              if (arg !== undefined) {
                opArguments.push(arg);
              }
            }
          }

          actionObject[name] = opArguments;

          actionObject.order = actionObject.order || [];
          actionObject.order.push(name);
        },
        action: function (object, actionObject) {
          if (!actionObject || !actionObject[name]) {
            return object;
          }

          var args = actionObject[name];
          if (!P.U.isArray(args)) {
            args = [args];
          }

          return object[name].apply(object, args);
        }
      };
    }
  }
};
opStoreAll = P.OpStore.all;

/**
 * Contains implementation of the ProAct.js DSL.
 * &lt;p>
 *  The idea of the DSL is to define {@link ProAct.Observable}s and their dependencies on each other in a declarative and simple way.
 * &lt;/p>
 * &lt;p>
 *  The {@link ProAct.Registry} is used to store these observables.
 * &lt;/p>
 * &lt;p>
 *  For example if we want to have a stream configured to write in a property, it is very easy done using the DSL:
 *  &lt;pre>
 *    ProAct.registry.prob('val', 0, '&lt;&lt;(s:data)');
 *  &lt;/pre>
 *  This tells the {@link ProAct.Registry} to create a {@link ProAct.Val} with the value of zero, and to point the previously,
 *  stored 'data' stream to it.
 * &lt;/p>
 *
 * @namespace ProAct.DSL
 */
ProAct.DSL = {

  /**
   * A separator which can be used to separate multiple DSL expressions in one string.
   *
   * @memberof ProAct.DSL
   * @static
   * @constant
   */
  separator: '|',

  /**
   * The operation definitions of the DSL.
   * &lt;p>
   *  All of the available and executable operations defined in the ProAct.DSL.
   * &lt;/p>
   * &lt;p>
   *  Users of ProAct.js can add their own operation to it.
   *  &lt;pre>
   *    ProAct.DSL.ops.myOp = ProAct.OpStore.all.simpleOp('foo', 'foo');
   *  &lt;/pre>
   * &lt;/p>
   *
   * @namespace ProAct.DSL.ops
   * @memberof ProAct.DSL
   * @static
   * @see {@link ProAct.OpStore}
   */
  ops: {

    /**
     * DSL operation for defining sources of {@link ProAct.Observable}s.
     * &lt;p>
     *  For example
     *  &lt;pre>
     *    '&lt;&lt;(s:bla)'
     *  &lt;/pre>
     *  means that the source of the targed of the DSL should be a stream stored in the {@link ProAct.Registry} by the key 'bla'.
     * &lt;/p>
     * &lt;p>
     *  or
     *  &lt;pre>
     *    '&lt;&lt;($1)'
     *  &lt;/pre>
     *  means that the source of the targed of the DSL should be an {@link ProAct.Observable} passed to the {@link ProAct.Dsl.run}
     *  method as the first argument after the targed object, the DSL data and the registry.
     * &lt;/p>
     *
     * @memberof ProAct.DSL.ops
     * @static
     * @constant
     * @see {@link ProAct.OpStore}
     * @see {@link ProAct.Registry}
     * @see {@link ProAct.Observable}
     * @see {@link ProAct.DSL.run}
     */
    into: opStoreAll.simpleOp('into', '&lt;&lt;'),

    /**
     * DSL operation for setting the targed of the DSL as sources of another {@link ProAct.Observable}s.
     * &lt;p>
     *  For example
     *  &lt;pre>
     *    '>>(s:bla)'
     *  &lt;/pre>
     *  means that the targed of the DSL should become a source for a stream stored in the {@link ProAct.Registry} by the key 'bla'.
     * &lt;/p>
     * &lt;p>
     *  or
     *  &lt;pre>
     *    '>>($1)'
     *  &lt;/pre>
     *  means that the targed of the DSL should become a source for an {@link ProAct.Observable} passed to the {@link ProAct.Dsl.run}
     *  method as the first argument after the targed object, the DSL data and the registry.
     * &lt;/p>
     *
     * @memberof ProAct.DSL.ops
     * @static
     * @constant
     * @see {@link ProAct.OpStore}
     * @see {@link ProAct.Registry}
     * @see {@link ProAct.Observable}
     * @see {@link ProAct.DSL.run}
     */
    out: opStoreAll.simpleOp('out', '>>'),

    /**
     * DSL operation for attaching listener to the target {@link ProAct.Observable} of the DSL.
     * &lt;p>
     *  For example
     *  &lt;pre>
     *    '@(f:bla)'
     *  &lt;/pre>
     *  means that listener function, stored in the {@link ProAct.Registry} as 'bla'
     *  should be attached as a listener to the targed {@link ProAct.Observable} of the DSL.
     * &lt;/p>
     *
     * @memberof ProAct.DSL.ops
     * @static
     * @constant
     * @see {@link ProAct.OpStore}
     * @see {@link ProAct.Registry}
     * @see {@link ProAct.Observable}
     * @see {@link ProAct.DSL.run}
     */
    on: opStoreAll.simpleOp('on', '@'),

    /**
     * DSL operation for adding mapping to the target {@link ProAct.Observable} of the DSL.
     * &lt;p>
     *  For example
     *  &lt;pre>
     *    'map(f:bla)'
     *  &lt;/pre>
     *  means that mapping function, stored in the {@link ProAct.Registry} as 'bla'
     *  should be mapped to the targed {@link ProAct.Observable} of the DSL.
     * &lt;/p>
     * &lt;p>
     *  or
     *  &lt;pre>
     *    'map($2)'
     *  &lt;/pre>
     *  means that mapping function passed to the {@link ProAct.Dsl.run}
     *  method as the second argument after the targed object, the DSL data and the registry
     *  should be mapped to the targed {@link ProAct.Observable} of the DSL.
     * &lt;/p>
     *
     * @memberof ProAct.DSL.ops
     * @static
     * @constant
     * @see {@link ProAct.OpStore}
     * @see {@link ProAct.Registry}
     * @see {@link ProAct.Observable}
     * @see {@link ProAct.DSL.run}
     */
    mapping: opStoreAll.simpleOp('mapping', 'map'),

    /**
     * DSL operation for adding filters to the target {@link ProAct.Observable} of the DSL.
     * &lt;p>
     *  For example
     *  &lt;pre>
     *    'filter(f:bla)'
     *  &lt;/pre>
     *  means that filtering function, stored in the {@link ProAct.Registry} as 'bla'
     *  should be add as filter to the targed {@link ProAct.Observable} of the DSL.
     * &lt;/p>
     * &lt;p>
     *  or
     *  &lt;pre>
     *    'filter($1)'
     *  &lt;/pre>
     *  means that filtering function passed to the {@link ProAct.Dsl.run}
     *  method as the first argument after the targed object, the DSL data and the registry
     *  should be added as filter to the targed {@link ProAct.Observable} of the DSL.
     * &lt;/p>
     *
     * @memberof ProAct.DSL.ops
     * @static
     * @constant
     * @see {@link ProAct.OpStore}
     * @see {@link ProAct.Registry}
     * @see {@link ProAct.Observable}
     * @see {@link ProAct.DSL.run}
     */
    filtering: opStoreAll.simpleOp('filtering', 'filter'),

    /**
     * DSL operation for adding accumulation to the target {@link ProAct.Observable} of the DSL.
     * &lt;p>
     *  For example
     *  &lt;pre>
     *    'acc($1, f:bla)'
     *  &lt;/pre>
     *  means that accumulating function, stored in the {@link ProAct.Registry} as 'bla'
     *  should be added as accumulation to the targed {@link ProAct.Observable} of the DSL,
     *  and the first argument passed to {@link ProAct.DSL.run} after the targed object, the DSL data and the registry should
     *  be used as initial value for the accumulation.
     * &lt;/p>
     *
     * @memberof ProAct.DSL.ops
     * @static
     * @constant
     * @see {@link ProAct.OpStore}
     * @see {@link ProAct.Registry}
     * @see {@link ProAct.Observable}
     * @see {@link ProAct.DSL.run}
     */
    accumulation: opStoreAll.simpleOp('accumulation', 'acc')
  },

  /**
   * A set of predefined operations to be used by the DSL.
   *
   * @namespace ProAct.DSL.predefined
   * @memberof ProAct.DSL
   * @static
   * @see {@link ProAct.DSL.ops}
   */
  predefined: {

    /**
     * A set of predefined mapping operations to be used by the DSL.
     *
     * @namespace ProAct.DSL.predefined.mapping
     * @memberof ProAct.DSL.predefined
     * @static
     * @see {@link ProAct.DSL.ops.map}
     */
    mapping: {

      /**
       * Mapping operation for changing the sign of a number to the oposite.
       * &lt;p>
       *  For example 4 becomes -4 and -5 becomes 5.
       * &lt;/p>
       * &lt;p>
       *  Usage in a DSL expression:
       *  &lt;pre>
       *    map(-)
       *  &lt;/pre>
       * &lt;/p>
       *
       * @memberof ProAct.DSL.predefined.mapping
       * @static
       * @method
       * @see {@link ProAct.DSL.ops.map}
       */
      '-': function (el) { return -el; },

      /**
       * Mapping operation for computing computing the square of a number.
       * &lt;p>
       *  For example 4 becomes 16.
       * &lt;/p>
       * &lt;p>
       *  Usage in a DSL expression:
       *  &lt;pre>
       *    map(pow)
       *  &lt;/pre>
       * &lt;/p>
       *
       * @memberof ProAct.DSL.predefined.mapping
       * @static
       * @method
       * @see {@link ProAct.DSL.ops.map}
       */
      'pow': function (el) { return el * el; },
      'sqrt': function (el) { return Math.sqrt(el); },
      'int': function (el) { return parseInt(el, 10); },
      '&.': function (arg) {
        return function (el) {
          var p = el[arg];
          if (!p) {
            return el;
          } else if (P.U.isFunction(p)) {
            return p.call(el);
          } else {
            return p;
          }
        };
      }
    },
    filtering: {
      'odd': function (el) { return el % 2 !== 0; },
      'even': function (el) { return el % 2 === 0; },
      '+': function (el) { return el >= 0; },
      '-': function (el) { return el &lt;= 0; }
    },
    accumulation: {
      '+': [0, function (x, y) { return x + y; }],
      '*': [1, function (x, y) { return x * y; }],
      '+str': ['', function (x, y) { return x + y; }],
    }
  },
  optionsFromString: function (optionString) {
    return dsl.optionsFromArray.apply(null, [optionString.split(dsl.separator)].concat(slice.call(arguments, 1)));
  },
  optionsFromArray: function (optionArray) {
    var result = {}, i, ln = optionArray.length,
        ops = P.R.ops, op, opType;
    for (i = 0; i &lt; ln; i++) {
      op = optionArray[i];
      for (opType in P.DSL.ops) {
        opType = P.DSL.ops[opType];
        if (opType.match(op)) {
          opType.toOptions.apply(opType, [result, op].concat(slice.call(arguments, 1)));
          break;
        }
      }
    }
    return result;
  },
  run: function (observable, options, registry) {
    var isS = P.U.isString,
        args = slice.call(arguments, 3),
        option, i, ln, opType;

    if (options && isS(options)) {
      options = dsl.optionsFromString.apply(null, [options].concat(args));
    }

    if (options && options instanceof P.Observable) {
      options = {into: options};
    }

    if (options && options.order) {
      ln = options.order.length;
      for (i = 0; i &lt; ln; i++) {
        option = options.order[i];
        if (opType = dslOps[option]) {
          if (registry) {
            options[option] = registry.toObjectArray(options[option]);
          }

          opType.action(observable, options);
          delete options[option];
        }
      }
    }

    for (opType in dslOps) {
      if (options && (option = options[opType])) {
        options[opType] = registry.toObjectArray(option);
      }
      opType = dslOps[opType];
      opType.action(observable, options);
    }

    return observable;
  }
};

dsl = P.DSL;
dslOps = dsl.ops;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Classes</h3><ul><li><a href="ProAct.Array.html">Array</a></li><li><a href="ProAct.ArrayCore.html">ArrayCore</a></li><li><a href="ProAct.ArrayProperty.html">ArrayProperty</a></li><li><a href="ProAct.AutoProperty.html">AutoProperty</a></li><li><a href="ProAct.BufferedStream.html">BufferedStream</a></li><li><a href="ProAct.Core.html">Core</a></li><li><a href="ProAct.DebouncingStream.html">DebouncingStream</a></li><li><a href="ProAct.DelayedStream.html">DelayedStream</a></li><li><a href="ProAct.Event.html">Event</a></li><li><a href="ProAct.Flow.html">Flow</a></li><li><a href="ProAct.NullProperty.html">NullProperty</a></li><li><a href="ProAct.ObjectCore.html">ObjectCore</a></li><li><a href="ProAct.ObjectProperty.html">ObjectProperty</a></li><li><a href="ProAct.Observable.html">Observable</a></li><li><a href="ProAct.Property.html">Property</a></li><li><a href="ProAct.Queue.html">Queue</a></li><li><a href="ProAct.Queues.html">Queues</a></li><li><a href="ProAct.Registry.html">Registry</a></li><li><a href="ProAct.SizeBufferedStream.html">SizeBufferedStream</a></li><li><a href="ProAct.Stream.html">Stream</a></li><li><a href="ProAct.ThrottlingStream.html">ThrottlingStream</a></li><li><a href="ProAct.Val.html">Val</a></li></ul><h3>Namespaces</h3><ul><li><a href="ProAct.html">ProAct</a></li><li><a href="ProAct.Array.Listeners.html">Listeners</a></li><li><a href="ProAct.Array.Operations.html">Operations</a></li><li><a href="ProAct.Configuration.html">Configuration</a></li><li><a href="ProAct.DSL.html">DSL</a></li><li><a href="ProAct.DSL.ops.html">ops</a></li><li><a href="ProAct.DSL.predefined.html">predefined</a></li><li><a href="ProAct.DSL.predefined.mapping.html">mapping</a></li><li><a href="ProAct.Event.Types.html">Types</a></li><li><a href="ProAct.OpStore.html">OpStore</a></li><li><a href="ProAct.Property.Types.html">Types</a></li><li><a href="ProAct.States.html">States</a></li><li><a href="ProAct.Utils.html">Utils</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.2.2</a> on Thu Jul 31 2014 10:03:09 GMT+0300 (EEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
